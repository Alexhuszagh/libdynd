Dynamic ND-Array Library Design
-------------------------------

This is a library that I (Mark Wiebe) am developing in a proprietary
fashion, within the spirit of NumPy, but designed to be comfortable
in C++. It's main goals are:

* Have a flexible and high-performance data type mechanism, which can
  be extended to have new data types with POD or object semantics.
* A simple strided memory layout like NumPy, with KEEPORDER semantics
  by default.
* A design that's flexible enough to allow the data to be stored
  in CPU memory, GPU memory, or distributed across a cluster in a global
  array.
* Delayed execution by default - all operations return views or
  arrays with their computation deferred.
* Include a compiler technology to take the deferred expression trees
  and create optimized execution plans. Either directly executing the
  expression tree, creating a compact block-based execution engine along
  the lines of numexpr, or JITting with LLVM.

Everything Is A View
--------------------

In NumPy, some operations return views, and others return copies. In
this library, the idea is that everything is a view, either directly via
a linear striding operation, or indirectly via an expression tree.
Leaf nodes of the expression trees can either be ndarrays themselves,
or rvalue array generators, such as a constant generator or a linear range
generator.

Every operation in the system produces a view of the inputs. Suppose we
have two arrays, 'a' and 'b'. If we assign 'c = a + b', 'c' is now a view
into the sum of 'a' and 'b'. Note that 'c' itself is now an rvalue array, as
there are multiple ways an assigned value could be split up between 'a' and
'b', so such an assignment is not unique. If we take a value of 'c', for
example 'c(0,0).as<float>()', then modify 'a(0,0)', taking that value of 'c'
again will be different. The view nature of this can be collapsed by running
'c.as_lvalue()' (function subject to renaming).

Some example ndarray_expr_node subclasses:

zero_gen<dtype>, one_gen<dtype>, constant_gen<dtype, value> (rvalue):
    Generates 0, 1 or arbitrary constant values, respectively.

int_range<integer dtype, origin, step[ndim], shape[ndim]> (rvalue):
    Generates an integer range. This structure can be preserved under
    remapping to multi-dimensional data and linear indexing.

constant_multiply<dtype, A, childnode> (maybe lvalue?):
    Maps the input value x to A * x.

constant_add<dtype, A, childnode> (maybe lvalue?):
    Maps the input value x to A + x.

multiply<dtype, childnode0, childnode1> (rvalue):
    Maps the input value x, y to x * y. Similar versions of add, subtract,
    divide, etc. The childnodes must have identical shapes.

linear_map<float/complex dtype, A, B, childnode> (maybe lvalue?):
    Maps the input value x to A*x + B. A linspace is an int_range followed by
    a linear_map. If A is non-zero, this is invertible, and we could
    treat this as an lvalue array. Whether this in general is desireable needs
    some thought.

broadcast_shape<ndim, shape[ndim], axismap[childnode.ndim], childnode>
    Broadcasts the childnode to the specified shape, according to the specified
    mapping of the axes. These nodes are added when necessary for multiply-type
    nodes.

flat_to_ndim<ndim, shape[ndim], strides[ndim], childnode> (lvalue):
    Maps a one-dimensional array to a multi-dimensional array.
    result[i[0], ..., i[ndim-1]] ==
    childnode[strides[0]*i[0] + ... + strides[ndim-1]*i[ndim-1]].

linear_index<ndim, shape[ndim], base[ndim], strides[ndim], childnode> (lvalue):
    Does a linear strided indexing operation into the childnode. This doesn't
    change the number of dimensions of the childnode.

To heuristically determine where to create temporaries, the nodes should indicate
an estimate of how many source node accesses are required for each result
element. For example, a matrix multiply node for an m by n times an n by r matrix,
would indicate 2*n for each output element.

To start, we consider two computational models for evaluating an ndarray expression
tree. 

All Data Should Be Aligned and in Native Byte Order
---------------------------------------------------

NumPy supports misaligned data, and data in both big-endian and little-endian
formats. This library should too, but allowing this flexibility everywhere adds
complexity and degrades performance. Instead, data which is not aligned and
in NBO will be exposed in the style of a "generator array". This works nicely
with the expression tree basis for the ndarray, allowing the evaluation code
to assume the data is well-behaved when provided with a strided array, and
enable buffering otherwise.

Some Notes
----------

* When output parameters are used, exception safety is not guaranteed.
  Since some operations could fail half-way through the operation,
  guaranteeing exception safety would require making a temporary copy.
  In the interests of efficiency, this is not done. For exception safety,
  use just functional-style operations.

Licensing
---------

Currently, I intend to control the copyright of all the code, not
granting any licenses to anyone else. I'd like to retain the ability
to use it freely as I'd like or open source it in a BSD or GPL license,
so incorporating 3rd party code under non-liberal licenses is unacceptable.
Probably I will incorporate some parts of NumPy, namely ones that I have
contributed, but which will need to be heavily modified to become pleasant
for C++.

Development Log
---------------

Sept 9, 2011

* Initial work on 'dtype' object design/implementation. The dtype is
  an object which once constructed, should never be modified, so it
  only has 'getter' functions, not setters. For more complex dtypes,
  the lifetime is managed by a reference count.

Sept 15, 2011

* Raw casting/assignment functions for converting data. This includes
  "immediate mode" versions for single and multiple elements, and
  "delayed mode" versions which return a function pointer with auxiliary
  data.

Sept 19, 2011

* Added error mode to raw casting/assignment, which can check for
  overflow, truncation of floating point fractional part, or floating
  point inexact conversion.

Sept 20, 2011

* Wrote ndarray.vassign function for scalar inputs. This allows you
  to assign a scalar (including a native C++ scalar) to arrays, with
  a customizable assignment error mode. While I could also make the
  C++ scalar assignment work with ndarray.operator=, I think the ndarray
  assignment operator should be reserved for ndarray reference assignment
  semantics, overloading it would be confusing.

Sept 22, 2011

* Wrote an irange() class, similar to Boost MultiArray's index_range(),
  to support range-based indexing. This is like slice-based indexing in
  Python. Also implemented the indexing in ndarray using operator(). Thought
  about how operator[] might work - Boost MultiArray uses it and can
  do it because whether an index is an integer or a tuple of ranges is
  determined at compile time. In irange() I've allowed it to represent
  an integer index by setting step to zero, something which simplifies the
  implementation for multiple indexing.

Sept 27, 2011

* Over the past few days, have made the arithmetic operators +, -, *, / work. This
  required filling in the iterator mechanism (currently using the object
  raw_ndarray_iter templated on the number of outputs and the number of inputs). 


