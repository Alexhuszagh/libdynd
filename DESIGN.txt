Dynamic ND-Array Library Design
-------------------------------

This is a library that I (Mark Wiebe) am developing in a proprietary
fashion, within the spirit of NumPy, but designed to be comfortable
in C++. It's main goals are:

* Have a flexible and high-performance data type mechanism, which can
  be extended to have new data types with POD or object semantics.
* A simple strided memory layout like NumPy, with KEEPORDER semantics
  by default.
* A design that's flexible enough to allow the data to be stored
  in CPU memory, GPU memory, or distributed across a cluster in a global
  array.
* Delayed execution by default - all operations return views or
  arrays with their computation deferred.
* Include a compiler technology to take the deferred expression trees
  and create optimized execution plans. Either directly executing the
  expression tree, creating a compact block-based execution engine along
  the lines of numexpr, or JITting with LLVM.

Some Notes
----------

* When output parameters are used, exception safety is not guaranteed.
  Since some operations could fail half-way through the operation,
  guaranteeing exception safety would require making a temporary copy.
  In the interests of efficiency, this is not done. For exception safety,
  use just functional-style operations.

Licensing
---------

Currently, I intend to control the copyright of all the code, not
granting any licenses to anyone else. I'd like to retain the ability
to use it freely as I'd like or open source it in a BSD or GPL license,
so incorporating 3rd party code under non-liberal licenses is unacceptable.
Probably I will incorporate some parts of NumPy, namely ones that I have
contributed, but which will need to be heavily modified to become pleasant
for C++.

Development Log
---------------

Sept 9, 2011

* Initial work on 'dtype' object design/implementation. The dtype is
  an object which once constructed, should never be modified, so it
  only has 'getter' functions, not setters. For more complex dtypes,
  the lifetime is managed by a reference count.

Sept 15, 2011

* Raw casting/assignment functions for converting data. This includes
  "immediate mode" versions for single and multiple elements, and
  "delayed mode" versions which return a function pointer with auxiliary
  data.

Sept 19, 2011

* Added error mode to raw casting/assignment, which can check for
  overflow, truncation of floating point fractional part, or floating
  point inexact conversion.

Sept 20, 2011

* Wrote ndarray.vassign function for scalar inputs. This allows you
  to assign a scalar (including a native C++ scalar) to arrays, with
  a customizable assignment error mode. While I could also make the
  C++ scalar assignment work with ndarray.operator=, I think the ndarray
  assignment operator should be reserved for ndarray reference assignment
  semantics, overloading it would be confusing.

Sept 22, 2011

* Wrote an irange() class, similar to Boost MultiArray's index_range(),
  to support range-based indexing. This is like slice-based indexing in
  Python. Also implemented the indexing in ndarray using operator(). Thought
  about how operator[] might work - Boost MultiArray uses it and can
  do it because whether an index is an integer or a tuple of ranges is
  determined at compile time. In irange() I've allowed it to represent
  an integer index by setting step to zero, something which simplifies the
  implementation for multiple indexing.
